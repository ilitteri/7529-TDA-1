\documentclass[../main.tex]{subfiles}

\section{Objetivos}
\subfile{../secciones/objetivos_parte_1.tex}

\subsection{Algoritmo de Johnson}

El algoritmo de Johnson es un algoritmo cuya finalidad es hallar el camino más corto entre todos los pares de vértices de un grafo dirigido disperso. Permite que las aristas tengan pesos negativos, pero no que los ciclos tengan peso negativo.

Se basa en dos algoritmos:
el algoritmo de Bellman-Ford, el cual realiza una transformación en el grafo inicial, eliminando todas las aristas de peso negativo.
el algoritmo de Dijkstra, usandolo en el grafo resultante de utilizar el algoritmo anterior.

\subsubsection{¿Cómo funciona?}

Para aplicar el algoritmo, se siguen los siguientes pasos:

\begin{enumerate}
    \item Se agrega un nodo $q$ al grafo, el cual está conectado a cada uno de los nodos del grafo por una arista de peso cero.
    \item Se utiliza el algoritmo de Bellman-Ford, empezando por el nuevo vértice $q$, para determinar para cada vértice $v$ el peso mínimo $h(v)$ del camino de $q$ a $v$.
    → Si en este paso se detecta un ciclo negativo, el algoritmo concluye.
    \item Se actualiza el peso de las aristas del grafo, usando lo calculado anteriormente: una arista de $u$ a $v$ con tamaño $w(u, v)$, da el nuevo tamaño $w(u, v) + h(u) – h(v)$
    \item Para cada nodo s se usa el algoritmo de Dijkstra para determinar el camino más corto entre s y los otros nodos, usando el grafo actualizado anteriormente.
\end{enumerate}

Como todas las aristas tienen ahora un peso actualizado con el mismo agregado de  h(u) – h(v), nos aseguramos de que el camino más corto en el grafo original lo sea también en el grafo actualizado. 

También, debido al modo en el que computamos los valores h(v), nos aseguramos de que todos los pesos de las aristas son no negativos.
Esto último aporta la optimalidad de los caminos encontrados por Dijkstra.

\subsubsection{¿Es óptimo?}

Cuando analizamos algoritmos lo que nos interesa de ellos es analizar su optimalidad y su eficiencia. La optimalidad nos dice si, al utilizar un algoritmo en específico para resolver un problema, siempre obtengo el resultado correcto; y por otro lado la eficiencia (tanto en tiempo y espacio) tiene que ver con la cantidad de operaciones que se realizan para resolver el problema.

Para el problema que nos interesa resolver, este algoritmo sí es óptimo ya que se nos aclara que los grafos de nuestro problema no poseen ciclos negativos. Sin esa aclaración, se podría decir que el algoritmo no es óptimo ya que no devuelve el resultado correcto con grafos que contienen ciclos negativos.

\subsection{Comparación de complejidad temporal y espacial entre los algoritmos propuestos}

\begin{table}[H]
    \centering
    \begin{tabular}{| c | c | c | c |}
        \hline
        Complejidad & Bellman-Ford & Johnson & Floyd-Warshall\\
        \hline
        Temporal & $\mathcal{O}(VE)$ & $\mathcal{O}(V^{2}\log{V} + VE)$ & $\mathcal{O}(V^{3})$\\
        \hline
        Espacial & $\mathcal{O}(VE)$ & $\mathcal{O}((V+1)(E+V))$ & $\mathcal{O}()$ \\
        \hline
    \end{tabular}
\end{table}

\subsection{Comparación entre situaciones}

Johnson es mejor para grafos discretos y Floyd-Warshall para grafos densos porque la complejidad de éste depende sólo de la cantidad de vértices ($|V|$).

\subsection{Ejemplo}

INSERTAR GRAFO ORIGINAL ACÁ

\subsubsection{Paso 1. Se añade un nuevo vértice $q$ al grafo, conectado a cada uno de los vértices del grafo por una arista de peso cero}

INSERTAR GRAFO CON NUEVO VÉRTICE ACÁ

\subsubsection{Paso 2. Se utiliza el algoritmo de Bellman-Ford, empezando por el nuevo vértice $q$, para determinar para cada vértice $v$ el peso mínimo $h(v)$ del camino de $q$ a $v$. Si en este paso se detecta un ciclo negativo, el algoritmo concluye}

% Tabla para Bellman-Ford
\begin{table}[H]
    \centering
    \begin{tabular}{| c | c | c | c | c | c | c |}
        \hline
         & $q$ & $v_{0}$ & $v_{1}$ & $v_{2}$ & $v_{3}$ & $v_{4}$\\
        \hline
        0 &  &  &  &  &  &  \\
        \hline
        1 &  &  &  &  &  &  \\
        \hline
        2 &  &  &  &  &  &  \\
        \hline
        3 &  &  &  &  &  &  \\
        \hline
        4 &  &  &  &  &  &  \\
        \hline
    \end{tabular}
\end{table}

\subsubsection{Paso 3. }

\subsubsection{Paso 4. Para cada nodo $s$ se usa el algoritmo de Dijkstra para determinar el camino más corto entre $s$ y los otros nodos, usando el grafo actualizado anteriormente.}

\begin{table}[H]
    \centering
    \begin{tabular}{| c | c | c | c | c | c |}
        \hline
         & $v_{0}$ & $v_{1}$ & $v_{2}$ & $v_{3}$ & $v_{4}$\\
        \hline
        $v_{0}$ &  &  &  &  &  \\
        \hline
        $v_{1}$ &  &  &  &  &  \\
        \hline
        $v_{2}$ &  &  &  &  &  \\
        \hline
        $v_{3}$ &  &  &  &  &  \\
        \hline
        $v_{4}$ &  &  &  &  &  \\
        \hline
    \end{tabular}
\end{table}

\begin{table}[H]
    \centering
    \begin{tabular}{| c | c | c | c | c | c |}
        \hline
         & $v_{0}$ & $v_{1}$ & $v_{2}$ & $v_{3}$ & $v_{4}$\\
        \hline
        $v_{0}$ &  &  &  &  &  \\
        \hline
        $v_{1}$ &  &  &  &  &  \\
        \hline
        $v_{2}$ &  &  &  &  &  \\
        \hline
        $v_{3}$ &  &  &  &  &  \\
        \hline
        $v_{4}$ &  &  &  &  &  \\
        \hline
    \end{tabular}
\end{table}

\begin{table}[H]
    \centering
    \begin{tabular}{| c | c | c | c | c | c |}
        \hline
         & $v_{0}$ & $v_{1}$ & $v_{2}$ & $v_{3}$ & $v_{4}$\\
        \hline
        $v_{0}$ &  &  &  &  &  \\
        \hline
        $v_{1}$ &  &  &  &  &  \\
        \hline
        $v_{2}$ &  &  &  &  &  \\
        \hline
        $v_{3}$ &  &  &  &  &  \\
        \hline
        $v_{4}$ &  &  &  &  &  \\
        \hline
    \end{tabular}
\end{table}

\begin{table}[H]
    \centering
    \begin{tabular}{| c | c | c | c | c | c |}
        \hline
         & $v_{0}$ & $v_{1}$ & $v_{2}$ & $v_{3}$ & $v_{4}$\\
        \hline
        $v_{0}$ &  &  &  &  &  \\
        \hline
        $v_{1}$ &  &  &  &  &  \\
        \hline
        $v_{2}$ &  &  &  &  &  \\
        \hline
        $v_{3}$ &  &  &  &  &  \\
        \hline
        $v_{4}$ &  &  &  &  &  \\
        \hline
    \end{tabular}
\end{table}

\begin{table}[H]
    \centering
    \begin{tabular}{| c | c | c | c | c | c |}
        \hline
         & $v_{0}$ & $v_{1}$ & $v_{2}$ & $v_{3}$ & $v_{4}$\\
        \hline
        $v_{0}$ &  &  &  &  &  \\
        \hline
        $v_{1}$ &  &  &  &  &  \\
        \hline
        $v_{2}$ &  &  &  &  &  \\
        \hline
        $v_{3}$ &  &  &  &  &  \\
        \hline
        $v_{4}$ &  &  &  &  &  \\
        \hline
    \end{tabular}
\end{table}




\subsection{¿Puede decirse que Johnson utiliza en su funcionamiento una metodología greedy?}

Se podría decir que una parte de su funcionamiento utiliza una metodología greedy ya que este algoritmo usa el algoritmo de Dijkstra y éste utiliza en su funcionamiento una metodología Greedy, porque siempre elije el vértice 'más liviano' o 'más cercano' en $V-S$ para agregar al conjunto $S$ (siendo $S$ el conjunto de los vértices cuyos pesos finales de la fuente $s$ ya se han determinado). Decimos 'una parte' porque además el algoritmo de Johnson en una parte de su funcionamiento utiliza el algoritmo de Bellman-Ford (que no utiliza en su funcionamiento una metodología greedy).


\subsection{¿Puede decirse que Johnson utiliza en su funcionamiento una metodología de programación dinámica?}

Se podría decir que una parte de su funcionamiento utiliza una metodología de programación dinámica ya que este algoritmo (como se dijo en el punto anterior) usa el algoritmo de Bellman-Ford. Decimos 'una parte' porque además el algoritmo de Johnson en una parte de su funcionamiento utiliza el algoritmo de Bellman-Ford (que no utiliza en su funcionamiento una metodología greedy).